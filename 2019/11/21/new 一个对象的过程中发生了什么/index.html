<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/img/hufei/fei.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/hufei/fei.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/hufei/fei.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"huminxi.netlify.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="JVM 在 new 一个对象的时候，会先查看对象所属的类有没有被加载到内存。如果没有的话，就通过类的全限定名来加载，等类加载完成之后，再创建对象。总的来说， new 一个对象可以分为两个过程：类加载和创建对象。">
<meta property="og:type" content="article">
<meta property="og:title" content="new 一个对象的过程中发生了什么">
<meta property="og:url" content="https://huminxi.netlify.com/2019/11/21/new%20%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/index.html">
<meta property="og:site_name" content="黄枫谷">
<meta property="og:description" content="JVM 在 new 一个对象的时候，会先查看对象所属的类有没有被加载到内存。如果没有的话，就通过类的全限定名来加载，等类加载完成之后，再创建对象。总的来说， new 一个对象可以分为两个过程：类加载和创建对象。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huminxi.netlify.com/img/hufei/2019/11/class-life-cycle.png">
<meta property="og:image" content="https://huminxi.netlify.com/img/hufei/2019/11/not-initialization.png">
<meta property="og:image" content="https://huminxi.netlify.com/img/hufei/2019/11/class-loader.png">
<meta property="og:image" content="https://huminxi.netlify.com/img/hufei/2019/11/classloader-delegation-model.png">
<meta property="og:image" content="https://huminxi.netlify.com/img/hufei/2019/11/load-class.png">
<meta property="article:published_time" content="2019-11-21T07:16:09.000Z">
<meta property="article:modified_time" content="2025-04-29T08:33:31.112Z">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="创建对象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huminxi.netlify.com/img/hufei/2019/11/class-life-cycle.png">


<link rel="canonical" href="https://huminxi.netlify.com/2019/11/21/new%20%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://huminxi.netlify.com/2019/11/21/new%20%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","path":"2019/11/21/new 一个对象的过程中发生了什么/","title":"new 一个对象的过程中发生了什么"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>new 一个对象的过程中发生了什么 | 黄枫谷</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">黄枫谷</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">勿在浮沙筑高台。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.</span> <span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">1.1.</span> <span class="nav-text">类加载的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">类的初始化条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">1.2.2.</span> <span class="nav-text">验证</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">文件格式验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">元数据验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">字节码验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">符号引用验证</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">1.2.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">1.2.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">破坏双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E7%A0%B4%E5%9D%8F"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">第一次被破坏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%A2%AB%E7%A0%B4%E5%9D%8F"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">第二次被破坏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%A2%AB%E7%A0%B4%E5%9D%8F"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">第三次被破坏</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">引用</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/img/hufei/huangfenggu.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/huminxicn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huminxicn" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huminxi0214@qq.com" title="E-Mail → mailto:huminxi0214@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://www.ruanyifeng.com/home.html" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;home.html" rel="noopener" target="_blank">阮一峰</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huminxi.netlify.com/2019/11/21/new%20%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/hufei/huangfenggu.png">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黄枫谷">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="new 一个对象的过程中发生了什么 | 黄枫谷">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          new 一个对象的过程中发生了什么
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-21 15:16:09" itemprop="dateCreated datePublished" datetime="2019-11-21T15:16:09+08:00">2019-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-29 16:33:31" itemprop="dateModified" datetime="2025-04-29T16:33:31+08:00">2025-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>JVM 在 new 一个对象的时候，会先查看对象所属的类有没有被加载到内存。如果没有的话，就通过类的全限定名来加载，等类加载完成之后，再创建对象。总的来说， new 一个对象可以分为两个过程：类加载和创建对象。</p>
<span id="more"></span>


<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>虚拟机把描述类的数据从 Class 文件（不一定存在于磁盘中，这里所说的 Class 文件应当是一串二进制的字节流，无论以何种形式存在都可以）加载到内存，并对数据进行连接和初始化，最终形成可以被虚拟机直接使用的 Class 对象。</p>
<p>与那些在编译时需要进行连接工作的语言不同，在 Java 语言里，Class 的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然令类加载时增加一些性能开销，但是会给 Java 应用程序带来高度的灵活性。</p>
<blockquote>
<p>例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其具体的实现类；用户可以通过 Java 预定义或自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGi 技术，都使用了 Java 语言运行期加载类的特性。</p>
</blockquote>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>从加载到内存中开始，到卸载出内存为止，类的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析这 3 个阶段统称为连接。</p>
<p><code>类的生命周期</code><br><img class-life-cycle src="/img/hufei/2019/11/class-life-cycle.png" width="100%" height="100%"></p>
<blockquote>
<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类加载的过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定。注意，这里笔者写的是按部就班地『开始』，而不是按部就班地『进行』或『完成』，强调这点是因为这些阶段通常都是互相交叉进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</p>
</blockquote>
<h4 id="类的初始化条件"><a href="#类的初始化条件" class="headerlink" title="类的初始化条件"></a>类的初始化条件</h4><p>什么情况下需要开始类加载过程的第一个阶段？Java 虚拟机规范中并没有进行强制约束，这由具体的虚拟机实现自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了以下 5 种情况必须立即对类进行『初始化』（加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main 方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果包含 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<p>对于这 5 种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：『有且仅有』，这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。下面举 3 个例子来说明何为被动引用：</p>
<p><code>代码示例 1-1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int value = 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SubClass extends SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SubClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConstClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;ConstantClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String HELLO_WORLD=&quot;hello world&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 例子1：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</span><br><span class="line">         */</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        /**</span><br><span class="line">         * 例子2：通过数组定义来引用类，不会触发此类的初始化</span><br><span class="line">         */</span><br><span class="line">        SuperClass[] sca = new SuperClass[10];</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 例子3：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span><br><span class="line">         */</span><br><span class="line">        System.out.println(ConstClass.HELLO_WORLD);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>运行结果</code><br><img not-initialization src="/img/hufei/2019/11/not-initialization.png" width="100%" height="100%"></p>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>接下来我们详细讲解一下 Java 虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这 5 个阶段所执行的具体动作。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载是类加载过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下 3 件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在方法区中生成一个代表这个类的 java.lang.Class 对象，作为这个类的访问入口。</li>
</ul>
<blockquote>
<p>虚拟机规范的这 3 点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如『通过一个类的全限定名来获取定义此类的二进制字节流』这条，它没有指明二进制字节流要从一个 Class 文件中获取，准确地说是根本没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的舞台，Java 发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的 Java 技术都建立在这一基础之上，例如：</p>
<ul>
<li>从 ZIP 包中读取，这很常见，最终成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是 Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 $Proxy 的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li>
</ul>
</blockquote>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段是连接的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<blockquote>
<p>Java 语言本身是相对安全的语言（相对于 C&#x2F;C++ 来说），使用纯粹的 Java 代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面已经说过，Class 文件并不一定要求用 Java 源码编译而来，可以使用任何途径产生，甚至可以用十六进制编辑器直接编写 Class 文件。在字节码语言层面上，上述 Java 代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证 Class 文件是虚拟机对自身的一种保护工作。</p>
</blockquote>
<p>验证又大致分为 4 个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>第一阶段要验证字节流是否符合 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/21486985">Class 文件格式</a> 的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数 0xCAFEBABE 开头。</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据。<br>…</li>
</ul>
<h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
</ul>
<h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个 int 类型的数据，使用时却按 long 类型来加载入本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。<br>…</li>
</ul>
<p><strong>如果一个方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</strong> 即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">停机问题</a>。</p>
<h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合字段描述符所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。<br>…</li>
</ul>
<p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p>
<blockquote>
<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，就可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。这里有两点需要强调一下：</p>
<ul>
<li>这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</li>
<li>这里所说的初始值『通常情况』下是数据类型的零值。</li>
</ul>
<p>假设一个类变量的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value=123;</span><br></pre></td></tr></table></figure>

<p>那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。把 value 赋值为 123 的 putstatic 指令存放于类构造器方法 <code>&lt;clinit&gt;()</code> 之中，所以把 value 赋值为 123 的动作将在初始化阶段执行。下表列出了 Java 中所有基本数据类型的零值。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>long</td>
<td>0 L</td>
<td>float</td>
<td>0.0 f</td>
</tr>
<tr>
<td>short</td>
<td>(short) 0</td>
<td>double</td>
<td>0.0 d</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
<td>reference</td>
<td>null</td>
</tr>
<tr>
<td>byte</td>
<td>(byte) 0</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>上面提到，在『通常情况』下初始值是零值，那么也存在一些『特殊情况』。如果将类变量 value 的定义改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int value=123;</span><br></pre></td></tr></table></figure>
<p>那么在准备阶段时，虚拟机会直接将 value 赋值为 123。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是类加载过程的最后一步，在前面的类加载过程中，除了加载阶段用户应用程序可以通过自定义的类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。</p>
<p><strong>在准备阶段，变量已经赋过一次系统要求的零值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</strong> 或者可以从另外一个角度来表达：初始化阶段是执行类构造器方法 <code>&lt;clinit&gt;()</code> 的过程。</p>
<p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码示例 1-2 所示。</p>
<p><code>代码示例 1-2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0; //给变量赋值可以正常编译通过。</span><br><span class="line">        System.out.println(i); //这句编译器会提示 &quot;illegal forward reference&quot;。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>虚拟机设计团队把加载阶段中『通过一个类的全限定名来获取定义此类的二进制字节流』这个动作放到了 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为类加载器。</p>
<blockquote>
<p>类加载器可以说是 Java 语言的一项创新，也是 Java 语言流行的重要原因之一，它最初是为了满足 Java Applet 的需求而开发出来的。虽然目前 Java Applet 技术基本上已经死掉，但类加载器却在类层次划分、OSGi、热部署、<a target="_blank" rel="noopener" href="https://blog.csdn.net/TimHeath/article/details/52884482">代码加密</a>等领域大放异彩，成为了 Java 技术体系中一块重要的基石，可谓是失之东隅，收之桑榆。</p>
</blockquote>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于加载阶段。<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否『相等』，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<blockquote>
<p>这里所指的『相等』，包括代表类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属类型的判定。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。代码示例 1-3 演示了不同的类加载器对 instanceof 关键字运算结果的影响。</p>
</blockquote>
<p><code>代码示例 1-3</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 类加载器与 instanceof 关键字演示</span><br><span class="line"> */</span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        ClassLoader myLoader = new ClassLoader() &#123;</span><br><span class="line">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    if (is == null) &#123;</span><br><span class="line">                        return super.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    byte[] b = new byte[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    return defineClass(name, b, 0, b.length);</span><br><span class="line">                &#125;catch (Exception e) &#123;</span><br><span class="line">                    throw new ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj = myLoader.loadClass(&quot;jvm.clazz.ClassLoaderTest&quot;).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj instanceof jvm.clazz.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>运行结果</code><br><img class-loader src="/img/hufei/2019/11/class-loader.png" width="100%" height="100%"></p>
<blockquote>
<p>代码清单 1-3 中构造了一个简单的类加载器。它可以加载与自己在同一路径下的 Class 文件。我们使用这个类加载器去加载了一个名为 jvm.clazz.ClassLoaderTest 的类，并实例化了这个类的对象。两行输出结果中，从第一行可以看出，这个对象确实是类 jvm.clazz.ClassLoaderTest 实例化出来的对象，但从第二行可以发现，这个对象与类 jvm.clazz.ClassLoaderTest 做所属类型检查的时候却返回了 false。这是因为虚拟机中存在了两个 jvm.clazz.ClassLoaderTest 类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个 Class 文件，但依然是两个独立的类，做对象所属类型检查时结果自然为 false。</p>
</blockquote>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：</p>
<ul>
<li>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分。</li>
<li>另一种就是所有其它的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>从 Java 开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）<ul>
<li>这个类将器负责将存放在 <code>&lt;JAVA_HOME&gt;/jre/lib</code> 目录中的，并且是虚拟机识别的（按照文件名识别，如 rt.jar）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li>
</ul>
</li>
<li>扩展类加载器（Extension ClassLoader）<ul>
<li>这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 <code>&lt;JAVA_HOME&gt;/lib</code> 目录中的所有类库，开发者可以直接使用扩展类加载器。</li>
</ul>
</li>
<li>应用程序类加载器（Application ClassLoader）<ul>
<li>这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
</li>
</ul>
<p>我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如下图所示。</p>
<p><code>类加载器双亲委派模型</code><br><img classloader-delegation-model src="/img/hufei/2019/11/classloader-delegation-model.png" width="100%" height="50%"></p>
<blockquote>
<p>图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
</blockquote>
<blockquote>
<p>类加载器的双亲委派模型在 JDK 1.2 期间被引入并被广泛应用于之后几乎所有的 Java 程序中，但它并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的一种类加载器实现方式。</p>
</blockquote>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它不会首先加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到对应的类），子加载器才会尝试自己去加载。</p>
<blockquote>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如 java.lang.Object 类，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果读者有兴趣的话，可以尝试去编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但永远无法被加载运行。</p>
</blockquote>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>上文提到过双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过 3 较大规模的『被破坏』情况。</p>
<h5 id="第一次被破坏"><a href="#第一次被破坏" class="headerlink" title="第一次被破坏"></a>第一次被破坏</h5><p>双亲委派模型的第一次被破坏其实发生在双亲委派模型出现之前——即 JDK 1.2 发布之前。由于双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做出一些妥协。</p>
<blockquote>
<p>为了向前兼容，JDK 1.2 之后的 java.lang.ClassLoader 添加了一个新的 findClass() 方法，在此之前，用户去继承 java.lang.ClassLoader 的唯一目的就是重写 loadClass() 方法。因为双亲委派的具体逻辑就实现在 loadClass() 方法中，JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到新增的 findClass() 方法。在 loadClass() 方法的逻辑里，如果父类加载失败，则会调用 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p>
</blockquote>
<p><code>java.lang.ClassLoader 中的 loadClass() 方法</code><br><img load-class src="/img/hufei/2019/11/load-class.png" width="100%" height="50%"></p>
<h5 id="第二次被破坏"><a href="#第二次被破坏" class="headerlink" title="第二次被破坏"></a>第二次被破坏</h5><p>双亲委派模型的第二次被破坏是由这个模型自身的缺陷所导致的。双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的类加载器进行加载），<strong>基础类之所以称为『基础』，是因为它们总是作为被用户代码调用的 API</strong>，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？</p>
<blockquote>
<p>这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进了 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28909673">SPI,Service Provider Interface</a>）的代码，但启动类加载器不可能认识这些代码啊！那该怎么办？</p>
</blockquote>
<blockquote>
<p>为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
</blockquote>
<blockquote>
<p>有了线程上下文类加载器，就可以做一些『舞弊』的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。</p>
</blockquote>
<h5 id="第三次被破坏"><a href="#第三次被破坏" class="headerlink" title="第三次被破坏"></a>第三次被破坏</h5><p>双亲委派模型的第三次被破坏是由于用户对程序动态性的追求而导致的。这里所说的『动态性』指的是当前一些非常热门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。<strong>对于个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。</strong></p>
<blockquote>
<p>Sun 公司所提出的 JSR-294、JSR-277 规范在与 JCP 组织的模块化规范之争中落败给 JSR-291（即 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/OSGi">OSGi</a> R4.2），虽然 Sun 不甘失去 Java 模块化的主导权，独立在发展 Jigsaw 项目，但目前 OSGi 已经成为了业界『事实上』的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。</p>
</blockquote>
<p><strong>虽然使用了『被破坏』这个词来形容上述不符合双亲委派模型原则的行为，但这里『被破坏』并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可认为是一种创新。</strong> 正如 OSGi 中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在 Java 程序员中基本有一个共识：OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，就可以算是掌握了类加载器的精髓。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>创建对象可分为 3 个步骤：</p>
<ul>
<li>在堆区分配对象需要的内存<ul>
<li>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量。</li>
</ul>
</li>
<li>对所有实例变量赋零值<ul>
<li>将方法区内对实例变量的定义拷贝一份到堆区，然后赋零值。</li>
</ul>
</li>
<li>执行实例初始化代码<ul>
<li>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法。</li>
<li>如果有类似于 Child c &#x3D; new Child() 形式的 c 引用的话，在栈区定义 Child 类型引用变量 c，然后将堆区对象的地址赋值给它。</li>
<li>需要注意的是，每个子类对象持有父类对象的引用，可在内部通过 super 关键字来调用父类对象，但在外部不可访问。</li>
</ul>
</li>
</ul>
<p>通过实例引用调用实例方法时，先从方法区中对象的类型信息中找，找不到的话再去父类的类型信息中找。如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TJEOZzrjQV4Ly3pwSfUhcg">虚方法表</a> 的方式来优化调用的效率。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NGgMBE1M3i_nl5aqhYu5_g">PDD面试题：new一个对象的过程中发生了什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/21486985">深入理解Java Class文件格式（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TJEOZzrjQV4Ly3pwSfUhcg">这个世界根本没有什么面向对象！</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/" rel="tag"># 创建对象</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/10/31/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B9%8B%E4%B8%89%E5%AE%9E%E7%8E%B0/" rel="prev" title="Java 垃圾收集三 实现">
                  <i class="fa fa-angle-left"></i> Java 垃圾收集三 实现
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/12/10/Java%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" rel="next" title="Java 程序编译与代码优化">
                  Java 程序编译与代码优化 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
